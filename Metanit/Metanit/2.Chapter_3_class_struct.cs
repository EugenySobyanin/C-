// Глава 3.
// Классы, структуры и пространства имен.


// Конструкции верхнего уровня для проверки работы программы

using System.Net;
using System.Reflection;

Film obj1 = new Film("Пираты", 7.5, true);
obj1.PrintInfo();

Person obj2 = new Person();
Console.WriteLine($"{obj2.name} - {obj2.age}");

Music obj3 = new Music("Лунная соната.");
obj3.Print();

Film obj4 = new Film { title = "Чеба", rating=10, isWatched=false }; // для этого должен быть конструктор без параметров
obj4.PrintInfo();

Song obj5 = new Song {title = "Песенка", author = {name = "Снупи" } }; // пример с вложенным инициализатором
Song obj6 = new Song ();
obj5.Print();
obj6.Print();

Food obj7 = new Food("Пицца", 12); // пример работы деконструктора
(string t, int c) = obj7;
(_, int c2) = obj7;
Console.WriteLine($"{t} - {c} - {c2}");

// Классы и объекты_____________________________________________________________________________________________________________________________________________________________

// Пример реализации простого класса

class Film
{
    public string title;
    public double rating;
    public bool isWatched;

    public Film() 
    { }

    public Film (string title, double rating, bool isWatched)
    {
        this.title = title;
        this.rating = rating;
        this.isWatched = isWatched;
    }

    public void PrintInfo()
    {
        if (isWatched)
        {
            Console.Write($"Ты посмотрел фильм: ");
        }
        else 
        {
            Console.Write($"Посмотри фильм: ");
        }
        Console.WriteLine($"{title} - {rating}");
    }
}


//Конструкторы, инициализаторы и деконструкторы______________________________________________________________________________________________________________________________

// Простой пример с перегруженными конструкторами

class Person
{
    public string name;
    public int age;

    public Person() : this("Неизвестен") // первый конструктор вызывает второй
    { }
    public Person(string name) : this(name, 30) // вторуй конструктор вызывает третий
    { }
    public Person(string name, int age) // третий конструктор
    {
        this.name = name;
        this.age = age;
    }
}


// Первичные конструкторы
// - это добавление параметров к определению класса
//  За кадром для каждого параметра первичного конструктора в классе создается приватное поле, которое хранит значение параметра

public class Music(string title, string author)
{
    public Music(string title) : this(title, "Бетховен") // конструктор вызывает первичный конструктор
    { }
    public void Print() => Console.WriteLine($"{title} - {author}");
}


// Инициализаторы
// - это передача в фигурных скобках значений доступных полям
// Инициализаторы удобно применять, когда поле или свойство класса представляет другой класс:

public class Song
{
    public string title;
    public Author author;

    public Song()
    {
        title = "Без названия";
        author = new Author();
    }

    public void Print() => Console.WriteLine($"{title} - {author.name}");
}

public class Author
{
    public string name;

    public Author()
    {
        name = "Неизвестен";
    }
}


// Деконструкторы (не путать с деструкторами)

class Food
{
    public string title;
    public int coast;

    public Food(string title, int coast)
    {
        this.title = title;
        this.coast = coast;
    }

    public void Deconstruct(out string Title, out int Coast)
    {
        Title = title;
        Coast = coast;
    }

}


// Класс Program и метод Main. Программы верхнего уровня______________________________________________________________________________________________________________________
// С метода Main() начинается выполнение программы
// static void Main(string[] args){}
// Метод Main() находится в классе Program{}, другие классы помещаются вне класса Program{}
// Определения классов должны идти ниже чем инструкции верхнего уровня


// Типы значений и ссылочные типы______________________________________________________________________________________________________________________________________________
//Знчимые типы:
//    - Целочисленные типы(byte, sbyte, short, ushort, int, uint, long, ulong)
//    - Типы с плавающей запятой (float, double)
//    - Тип decimal
//    - Тип bool
//    - Тип char
//    - Перечисления enum
//    - Структуры(struct)

//Ссылочные типы:
//    - Тип object
//    - Тип string
//    - Классы (class)
//    - Интерфейсы(interface)
//    - Делегаты(delegate)

// Память делится на два типа: стек и куча (heap)
// Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке

// Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов.
// При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). 

// Тип данных надо учитывать при копировании значений. При присвоении данных объекту значимого типа он получает копию данных.
// При присвоении данных объекту ссылочного типа он получает не копию объекта, а ссылку на этот объект в хипе.

// Если ссылочные типы передавать в метод по значению, то будет использоваться копия ссылки на объект
// При передаче объекта класса по значению в метод передается копия ссылки на объект. Эта копия указывает на тот же объект,
// что и исходная ссылка, потому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект
// Но если использовать ref при передаче объекта, можно будет его менять


// Пространства имен_________________________________________________________________________________________________________________________________________________________
// Чтобы использовать класс вне пространства имено надо обратиться к нему через пространство имен, пример:
//Base.Person tom = new("Tom");
//tom.Print();          // Имя: Tom

//namespace Base
//{
//    class Person
//    {
//        string name;
//        public Person(string name) => this.name = name;
//        public void Print() => Console.WriteLine($"Имя: {name}");
//    }
//}
// Либо:
// Можно подключить пространство имен с помощью директивы using

// Так же можно в начале файла указать например: namespace Base; - тогда все содержимое файла будет относиться к этому неймспейсу


// Глобальные пространства имен________________________________________________________________________________________________________________________________________________
// Чтобы не подключать во все файлы проекта, можно подключить только в одном файле : global using Base; и тогда пространство будет доступно во всем проекте
// Лучше создавать отдельный файл для глобальных пространств имен


// Пространства имен по умолчанию________________________________________________________________________________________________________________________________________________


// Создание библиотеки классов в Visual Studio____________________________________________________________________________________________________________________________________
// Алгоритм
//  - Создание приложения - Библиотеки классов
//  - Компилируем созданный проект - rebuild
//  - Подключаем библиотеку классов к другому проекту Dependencies => Add Project Reference...
//  - Далее мы можем использовать пространство имен из библиотеки классов


// Модификаторы доступа____________________________________________________________________________________________________________________________________________________________
//- private - доступен только в рамках своего класса или структуры
//- private protected -доступен из любого места в своем классе или в производных классах, которые определены в той же сборке
//- file - применяется к типам, например, классам и структурам. Класс или структура с такми модификатором доступны только из текущего файла кода
//- protected: такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.
//- internal: компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.
//- protected internal: совмещает функционал двух модификаторов protected и internal. 
//Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.
//- public: публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.



// Свойства________________________________________________________________________________________________________________________________________________________________________
// Стандартное описание свойства:
//[модификаторы] тип_свойства название_свойства
//{
//    get { действия, выполняемые при получении значения свойства}
//    set { действия, выполняемые при установке значения свойства}
//}

// В блоке get выполняются действия по получению значения свойства. В этом блоке с помощью оператора return возвращаем некоторое значение
// В блоке set устанавливается значение свойства. В этом блоке с помощью параметра value мы можем получить значение, которое передано свойству.


